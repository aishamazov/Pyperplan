Основной файл программы - ``pyperplan.py``. 

Принимает как минимум один аргумент, файл задачи. В настоящее время поддерживаются только файлы PDDL.

Например ./pyperplan-master/src/pyperplan.py pyperplan-master/benchmarks/tpp/task01.pddl

Если передать только файл задачи, pyperplan постарается угадать домен исходя из имени файла задачи. Если имя файла задачи содержит номер, то pyperplan будет искать домен с именем ``domainNUMBER.pddl``. Если такой не существует, то будет искаться ``domain.pddl``. Если и такой не будет найдет, то выдаст ошибку.

Также можно на вход программе передать и имя домена:

./pyperplan-master/src/pyperplan.py pyperplan-master/benchmarks/tpp/domain.pddl pyperplan-master/benchmarks/tpp/task04.pddl

Существует несколько аргументов командной строки, которые вы можете указать для определения того, как pyperplan
должен решить проблему. По умолчанию, pyperplan использует breadth first search (bfs - поиск в ширину) в пространстве поиска и эвристику hff для оценки расстояния до цели (который игнорируется bfs). Используя параметры -H или -s, соотвественно можно выбрать дургой эвристический алгоритм или алгоритм поиска. Если
оставить один из них, будет использоваться значение по умолчанию.

Список доступных алгоритмов:

./pyperplan-master/src/pyperplan.py --help

После того, как план был найден, он сохраняется в файле с именем точно таким же, как у 
файла задачи, но с добавлением `` .soln``.

Файл `` soln`` содержит действия в LISP-подобной нотации.

++ PDDL представление ++ 

Разбор и представление PDDL находится в пакете `` pddl``.

Для каждого элемента в PDDL STRIPS задаче или домене есть калсс в ``pddl.pddl`` модуле. Эти классы заполняются парсером PDDL соответственно. Основной синтаксический анализ выполняется в `` pddl.parser``, где определен класс `` Parser``, который предоставляет методы для разбора файла домена и файла задачи. Он анализирует файл используя общий анализатор LISP, который заполняет абстрактное синтаксическое дерево. По этому дереву
затем проходится и узлы с определенными PDDL-ключами используются для генерации
экземпляров соответствующего класса из модуля `` pddl.pddl``.

++ Задание и обоснование (grounding) ++

После того, как домен и задача были разобраны на экземпляры `` Domain`` и `` Problem`` соответственно, они проходят этап grounding, на котором создается конретная задача планирования.

Этап grounding реализован в модуле `` grounding`` и в основном просто принимает задачу PDDL и возвращает экземпляр ``Task``, представляющий задачу поиска. Это контейнерный класс для набора
конкретных экземпляров Оператора. Действия больше не являются абстрактными определениями
с типами, но для любого применимого объекта в домене есть Оператор
который может быть применен к текущему состоянию и имеет конкретные результаты.

Это важный шаг перед выполнением поиска по задаче. Класс `` Task`` предоставляет функцию, которая помогает создать пространство поиска: `` get_successor_states`` возвращает список всех возможных состояний, которые могут быть достигнуты, используя только действительные операторы. Это создает древовидную структуру, которая на некоторых узлах содержит состояние цели. Фактическое планирование затем заключается в нахождении кратчайшего пути до состояния цели.

Пакет `` search`` содержит набор алгоритмов поиска, таких как поиск по ширине или A*. Модуль пространства поиска содержит структуру поиска SearchNode для создания пространства поиска, которое хранит информацию из поиска и позволяет быстро извлечь план.

++ SAT ++

Также можно найти планировщик SAT в поисковом пакете. Он использует решение minisat SAT для поиска плана для данной проблемы. Pyperplan кодирует проблему в булевой формуле в конъюнктивной нормальной форме до того, как она вызовет minisat. Чтобы использовать планировщик SAT, вы должны сделать исполняемый файл minisat доступным на
система PATH (например, / usr / local / bin /). После этого вы можете запустить планировщик с опцией `` --search sat``. Обратите внимание, что исполняемый файл иногда называемый «minisat2» в дистрибутивных пакетах (например, в некоторых версиях Ubuntu). Если это так, вам придется переименовать двоичный файл в «minisat».

++ Эвристики ++

Большинство наиболее продвинутых алгоритмов поиска - это // информированные // поисковые запросы, что означает, что им нужна информация о том, как далеко находится узел от цели. Такая информация берется из эвристики, которая, учитывая узел, возвращает, насколько далеко узел находится вдали от состояния цели.

Эвристики в pyperplan реализованы как модули в пакете `` heuristic``.